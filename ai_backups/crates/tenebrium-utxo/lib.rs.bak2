//! Tenebrium UTXO library
//!
//! Provides minimal UTXO-related types, JSON (serde_json) serialization helpers
//! and an in-memory UTXO set implementation for v0.1.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Maximum allowed script size in bytes (DoS mitigation)
pub const MAX_SCRIPT_SIZE: usize = 10_000;
/// Maximum allowed number of inputs or outputs in a transaction (temporary cap)
pub const MAX_TX_INOUTS: usize = 10_000;

/// Basic OutPoint identifying an output in a transaction
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct OutPoint {
    pub txid: [u8; 32],
    pub vout: u32,
}

/// Transaction input
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct TxIn {
    pub prevout: OutPoint,
    pub script_sig: Vec<u8>,
    pub sequence: u32,
}

/// Transaction output
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct TxOut {
    pub value: u64,
    pub script_pubkey: Vec<u8>,
}

/// Transaction
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Transaction {
    pub version: i32,
    pub vin: Vec<TxIn>,
    pub vout: Vec<TxOut>,
    pub lock_time: u32,
}

/// Errors for UTXO crate
#[derive(thiserror::Error, Debug)]
pub enum UtxoError {
    #[error("script too large: {0} bytes (max {1})")]
    TooLargeScript(usize, usize),
    #[error("too many inputs or outputs: {0} (max {1})")]
    TooManyInOut(usize, usize),
    #[error("serialization error: {0}")]
    SerdeError(#[from] serde_json::Error),
}

impl Transaction {
    /// Validate transaction fields for v0.1 policy
    pub fn validate(&self) -> Result<(), UtxoError> {
        if self.vin.len() > MAX_TX_INOUTS {
            return Err(UtxoError::TooManyInOut(self.vin.len(), MAX_TX_INOUTS));
        }
        if self.vout.len() > MAX_TX_INOUTS {
            return Err(UtxoError::TooManyInOut(self.vout.len(), MAX_TX_INOUTS));
        }
        for input in &self.vin {
            if input.script_sig.len() > MAX_SCRIPT_SIZE {
                return Err(UtxoError::TooLargeScript(input.script_sig.len(), MAX_SCRIPT_SIZE));
            }
        }
        for output in &self.vout {
            if output.script_pubkey.len() > MAX_SCRIPT_SIZE {
                return Err(UtxoError::TooLargeScript(output.script_pubkey.len(), MAX_SCRIPT_SIZE));
            }
        }
        Ok(())
    }

    /// Serialize to JSON bytes
    pub fn to_json_bytes(&self) -> Result<Vec<u8>, UtxoError> {
        serde_json::to_vec(self).map_err(UtxoError::from)
    }

    /// Deserialize from JSON bytes and run validation
    pub fn from_json_bytes(bytes: &[u8]) -> Result<Self, UtxoError> {
        let tx: Transaction = serde_json::from_slice(bytes)?;
        tx.validate()?;
        Ok(tx)
    }
}

/// UTXO set trait
pub trait UtxoSet {
    fn get(&self, outpoint: &OutPoint) -> Option<TxOut>;
    fn insert(&mut self, outpoint: OutPoint, txout: TxOut);
    fn remove(&mut self, outpoint: &OutPoint) -> Option<TxOut>;
}

/// In-memory HashMap-backed UTXO set
#[derive(Debug, Default)]
pub struct InMemoryUtxoSet {
    map: HashMap<OutPoint, TxOut>,
}

impl InMemoryUtxoSet {
    pub fn new() -> Self {
        Self { map: HashMap::new() }
    }
}

impl UtxoSet for InMemoryUtxoSet {
    fn get(&self, outpoint: &OutPoint) -> Option<TxOut> {
        self.map.get(outpoint).cloned()
    }

    fn insert(&mut self, outpoint: OutPoint, txout: TxOut) {
        self.map.insert(outpoint, txout);
    }

    fn remove(&mut self, outpoint: &OutPoint) -> Option<TxOut> {
        self.map.remove(outpoint)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tx_serde_json_roundtrip() -> Result<(), UtxoError> {
        let outpoint = OutPoint { txid: [0u8; 32], vout: 0 };
        let txin = TxIn { prevout: outpoint, script_sig: b"hello".to_vec(), sequence: 0xffffffff };
        let txout = TxOut { value: 50_000, script_pubkey: b"world".to_vec() };
        let tx = Transaction { version: 1, vin: vec![txin], vout: vec![txout], lock_time: 0 };

        let bytes = tx.to_json_bytes()?;
        let tx2 = Transaction::from_json_bytes(&bytes)?;
        assert_eq!(tx, tx2);
        Ok(())
    }

    #[test]
    fn script_length_limit_errs() {
        // build a tx with too-large script_sig
        let outpoint = OutPoint { txid: [1u8; 32], vout: 1 };
        let too_long = vec![0u8; MAX_SCRIPT_SIZE + 1];
        let txin = TxIn { prevout: outpoint, script_sig: too_long, sequence: 0 };
        let tx = Transaction { version: 1, vin: vec![txin], vout: vec![], lock_time: 0 };

        let res = tx.validate();
        assert!(res.is_err());
        match res.err().unwrap() {
            UtxoError::TooLargeScript(len, max) => {
                assert_eq!(len, MAX_SCRIPT_SIZE + 1);
                assert_eq!(max, MAX_SCRIPT_SIZE);
            }
            e => panic!("unexpected error: {:?}", e),
        }
    }

    #[test]
    fn in_memory_utxo_set_ops() {
        let mut set = InMemoryUtxoSet::new();
        let outpoint = OutPoint { txid: [2u8; 32], vout: 2 };
        let txout = TxOut { value: 100, script_pubkey: b"pk".to_vec() };

        assert!(set.get(&outpoint).is_none());
        set.insert(outpoint.clone(), txout.clone());
        assert_eq!(set.get(&outpoint), Some(txout.clone()));
        assert_eq!(set.remove(&outpoint), Some(txout.clone()));
        assert!(set.get(&outpoint).is_none());
    }
}
